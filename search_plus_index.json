{"./":{"url":"./","title":"Introduction","keywords":"","body":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂 跟著狂神學習，並記錄課程所學 每一個筆記章節下方均有包含相應的課程影片 多溝通 多問 好學 才能讓自己更進步 未來會學習更多關於 Spring MVC、Spring Boot 相關，學完此課程後再更新 "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/01、Spring的簡介組成與拓展/01、Spring的簡介組成與拓展.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/01、Spring的簡介組成與拓展/01、Spring的簡介組成與拓展.html","title":"01、Spring的簡介組成與拓展","keywords":"","body":"目錄 1、Spring 1-1、Spring Framework (Spring 框架) 1-2、Spring 官方教學文件與下載 1-3、Spring 的組成 1-5、Spring 的拓展 1、Spring 1-1、Spring Framework (Spring 框架) 導入 Spring Web MVC 就會引入很多其他包 org.springframework spring-webmvc 5.3.6 org.springframework spring-jdbc 5.3.6 總結: Spring 就是一個輕量級的控制反轉(IOC)和面相切面編程(AOP)的框架! 1-2、Spring 官方教學文件與下載 官方文件: 官網 > Projects > Spring Framework > Reference Doc. 官方下載: (一般直接用 maven 下載就好) 步驟一: 網址改為 {Spring Domain}/spring-framework/docs/4.3.9.RELEASE https://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/spring-framework-reference/html/overview.html#overview-distribution-zip 步驟二: 進入下方網址後即有所有版本的 spring http://repo.spring.io/release/org/springframework/spring Spring GitHub: https://github.com/spring-projects/spring-framework 1-3、Spring 的組成 Spring 由以下七大核心模块組成 1-5、Spring 的拓展 在 Spring 的官網有這個介紹: 現代化的 Java 開發! 說白就是基於 Spring 的開發! 因為現在大多數公司都在使用 Spring Boot 進行快速開發，學習 Spring Boot 的前提，需要完全掌握Spring 及 Spring MVC! 承上啟下的作用! 弊端: 發展太久後違背了原來的理念!配置十分繁瑣，人稱 \"配置地獄!\" 【狂神說Java】1、Spring 簡介 【狂神說Java】2、Spring 組成及拓展 Spring Framework spring框架 【Spring】Spring简介、组成及拓展 SSH Spring---七大核心模块 "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/02、IOC理論與推導/02、IOC理論與推導.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/02、IOC理論與推導/02、IOC理論與推導.html","title":"02、IOC理論與推導","keywords":"","body":"目錄 2、IOC 理論推導 2-1、IOC 推導 2-1-1、Spring 之 Maven 設定 2-1-2、創建 Spring 項目 2-1-3、基礎接口創建 2-1-4、Service 優化 2-1-5、使用 Set 接口實現的變化 2-2、IOC 本質 2、 IOC 理論推導 接口創建步驟 : 思想由此開始轉變 UserDao 接口 UserDaoImpl 實現類 UserService 業務接口 UserServiceImpl 業務實現類 2-1、IOC 推導 2-1-1、Spring 之 Maven 設定 建立 Project 創建 Maven 項目 設定詳細資訊 > Next (建立完成) 修改 pom.xml org.springframework spring-webmvc 5.3.6 Maven > Reload Project (Maven 套件加載，完成後可看見 Dependencies 資料夾) 2-1-2、創建 Spring 項目 Project 右鍵 > 創建 Model Next 修改 Name > Finish (Name 相同的話會有提示，需修改) 2-1-3、基礎接口創建 目錄 創建 UserDao.java package com.kuang.dao; public interface UserDao { void getUser(); } 創建 UserDaoImpl.java package com.kuang.dao; public class UserDaoImpl implements UserDao{ @Override public void getUser() { System.out.println(\"默認獲取用戶數據\"); } } 創建 UserDaoMySqlImpl.java package com.kuang.dao; public class UserDaoMySqlImpl implements UserDao{ @Override public void getUser() { System.out.println(\"獲取MySql數據\"); } } 創建 UserDaoOracleImpl.java package com.kuang.dao; public class UserDaoOracleImpl implements UserDao{ @Override public void getUser() { System.out.println(\"獲取Oracle數據\"); } } 創建 UserService.java package com.kuang.service; public interface UserService { void getUser(); } 創建 UserServiceImpl.java package com.kuang.service; import com.kuang.dao.UserDao; import com.kuang.dao.UserDaoImpl; public class UserServiceImpl implements UserService{ private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } MyTest.java (測試類)，之後可在此執行程式碼並進行測試 import com.kuang.service.UserService; import com.kuang.service.UserServiceImpl; public class MyTest { public static void main(String[] args) { // 這樣造成的缺點是，每創建一個新的 ServiceImpl 的話就要將 new UserServiceImpl() 改動。這樣會在後期程式碼改動會更大 UserService userService = new UserServiceImpl(); userService.getUser(); } } 2-1-4、Service 優化 修改 UserServiceImpl.java，代碼替用性更強 public class UserServiceImpl implements UserService{ // 舊寫法 : // private UserDao userDao = new UserDaoImpl(); private UserDao userDao; // 新增 set : // 利用 set 進行動態實現值的注入 public void setUserDao(UserDao userDao){ this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 新增 setUserDao 方法 package com.kuang.service; import com.kuang.dao.UserDao; public interface UserService { void setUserDao(UserDao userDao); void getUser(); } 修改 main 方法 import com.kuang.dao.UserDaoMySqlImpl; import com.kuang.service.UserService; import com.kuang.service.UserServiceImpl; public class MyTest { public static void main(String[] args) { // UserServiceImpl 不須再更動 UserService userService = new UserServiceImpl(); userService.setUserDao(new UserDaoMySqlImpl()); // 獲取MySql數據 userService.getUser(); } } 結論: 測試後會發現，值就會因 setUserDao 而改變，就無需重複且大量的修改資料 在之前的業務中，用戶的需求可能會影響我們的原來代碼，我們需要根據用戶的需求去修改原代碼!如果程序代碼量十分，修改一次的成本代價十分昂貴! 2-1-5、使用 Set 接口實現的變化 我們使用一個 Set 接口實現，已經發生了革命性的變化! private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } 之前，程序是主動創建對象!控制權在程序員手上! 使用了 set 注入後，程序不在具有主動性，而是被動的接受對象! 這種思想，從本質上解決了問題，我們程序員不用再去管理對象的創建了(就是不用在管理 new Object()，不須再修改 Object )。系統的耦合性大大降低~，可以更加專注的在業務的實現上(不需要修改Service了)! 2-2、 IOC 本質 控制反轉 IOC (Inversion of Control)，是一種設計思想，DI(依賴注入)是實現 IOC 的一種方法，也有人認為 DI 只是 IOC 的另一種說法。沒有IOC的程序中，我們使用面向對向編程，對象的創建與對象間的依賴關係完全硬編碼在程序中，對象的創建由程序自己控制，控制反轉後將對向的創建轉移給第三方，個人認為所謂控制反轉就是: 獲得依賴對象的方式反轉了。 IOC 是 Spring 框架的核心內容，使用多種方式完美的實現 IOC，可以使用 XML 配置，也可以使用註解，新版本的 Spring 也可以零配置 IOC (即自動裝配)。 Spring 容器在初始化時鮮讀取配置文件，根據配置文件或元數據創建與組織度向存入容器中，程序使用時在從IOC容器中取出需要的對象。 採用 XML 方式配置 Bean 時候，Bean 的定義信息是和實現分離的，而採用註解的方式可以把兩者合為一體，Bean 的定義信息直接以註解的形式定義在實現類中，從而達到了零配置的目的。 控制反轉是一種通過描述(XML或註解)通過第三方去生產或獲取特定對象的方式。在Spring中實現控制反轉的是IOC容器，其實現方法是依賴注入(Dependency Injection,DI)。 【狂神說Java】3、IOC 理論推導 【狂神說Java】4、IOC 本質 "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/03、HelloSpring/03、HelloSpring.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/03、HelloSpring/03、HelloSpring.html","title":"03、HelloSpring","keywords":"","body":"目錄 3、HelloSpring 3-1、開發前準備 3-2、控制反轉 HelloWorld 3-3、修改\"IOC 理論推導\"中的代碼並實現具體IOC 3-4、問題思考 3、HelloSpring 3-1、開發前準備 工具 : IDEA JDK : jdk1.8.0_231 Maven : apache-maven-3.6.3 3-2、控制反轉 HelloWorld 目錄 Project 右鍵 > New > Model > Maven > Next > Name > Finish Name: spring-02-hellospring 創建 Hello.java package com.kuang.pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Hello{\" + \"str='\" + str + '\\'' + '}'; } } 建立 beans.xml (xml 名稱可自訂) xml 範例取自官方文檔 Spring Framework 中文文檔 Spring 官方文檔 創建 MyTest.java (測試類) import com.kuang.pojo.Hello; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { // 獲取 Spring 的上下文對象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 我們的對象現在都在 Spring 中管理了，我們要使用，直接去裡面取出來就可以 Hello hello = (Hello) context.getBean(\"hello\"); System.out.println(hello.toString()); } } 3-3、修改\"IOC 理論推導\"中的代碼並實現具體IOC 目錄 建立 beans.xml (xml 名稱可自訂，目的是將對象改由Spring創建) xml 範例取自官方文檔 ```xml - **修改 MyTest.java** ```java import com.kuang.service.UserServiceImpl; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { // 獲取 ApplicationContext: 拿到 Spring 的容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 容器在手，天下我有，需要什麼，就直接 get 什麼 UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"UserServiceImpl\"); userServiceImpl.getUser(); } } 設定過後，未來只要修改配置文件就可以不動到主程式的情況下修改配置。假設 beans.xml 中 UserServiceImpl 要改使用 oracleImpl 的話，就將 property 的 ref 修改為 oracleImpl 就好 3-4、問題思考 Q: Hello 對象是誰創建的? A: hello 對象由 Spring 創建的 Q: Hello 對象的屬性是怎麼設置的? A: hello 對象的屬性是由 Spring 容器設置的 這個過程就叫做控制反轉: 控制: 誰來控制對象的創建，傳統應用程序的對象是由程序本身控制創建的，使用 Spring 後，對象是由 Spring 來創建的 反轉: 程序本身不創建對象，而變成被動的接收對象 依賴注入: 就是利用 set 方法來進行注入的。 IOC是一種編程思想，由主動的編程變成被動的接收。可以通過 newClassPathXmlApplicationContext 去瀏覽一下底層源碼。 OK，到了現在，我們徹底不用在程序中去改動了，要實現不同的操作，只需要在xml配置文件中進行修改，所謂 IOC 一句話搞定，對象由 Spring 來創建、管理、裝配! 【狂神說Java】5、HelloSpring "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/04、IOC創建對象方式/04、IOC創建對象方式.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/04、IOC創建對象方式/04、IOC創建對象方式.html","title":"04、IOC創建對象方式","keywords":"","body":"目錄 6、IOC創建對象方式 6-1、創建對象方式 6-2、實際測試 6、IOC創建對象方式 6-1、創建對象方式 使用無參構造創建對象 (默認!) 假設我們要使用有參構造創建對象 下標賦值 類型 參數名 6-2、實際測試 目錄結構 創 User.java package com.kuang.pojo; public class User { private String name; public User(String name){ this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"name=\"+name); } } 創 UserT.java package com.kuang.pojo; public class UserT { private String name; public UserT(){ System.out.println(\"UserT被創建了\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } } 建立空的 applicationContext.xml 建立 beans.xml 建立 MyTest.java import com.kuang.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { // Spring 容器，就類似於婚介網站! ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); /* UserT被創建了 name=秦疆 */ user.show(); System.out.println(user == user2); // true } } 總結: 在配置文件加載的時候，容器中管理的對象就已經初始化了! 【狂神說Java】6、IOC創建對象方式 "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/05、Spring配置說明/05、Spring配置說明.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/05、Spring配置說明/05、Spring配置說明.html","title":"05、Spring配置說明","keywords":"","body":"目錄 5、Spring 之 Bean 配置說明 5-1、Bean 之 alias 5-2、Bean 之 id、class、name 說明 5-3、Bean 中的 import 5、Spring 之 Bean 配置說明 5-1、Bean 之 alias alias 又稱 別名的配置 MyTest.java 修改 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"userNew\"); user.show(); user2.show(); System.out.println(user == user2); 結論: 不管是使用 user 或是 userNew 都可獲取到對象 5-2、Bean 之 id、class、name 說明 beans.xml 配置說明 java 演示 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserT user = (UserT) context.getBean(\"user2\"); UserT user2 = (UserT) context.getBean(\"u2\"); UserT user3 = (UserT) context.getBean(\"u3\"); UserT user4 = (UserT) context.getBean(\"u4\"); user.show(); user2.show(); System.out.println(user == user2); 結論: 不使用 alias 就可以做多個別名設定 5-3、Bean 中的 import 這個 import，一般用於團隊開發使用，他可以將多個配置文件導入併為一個 假設，現在項目中有多個人開發，這三人複製不同的類開發，不同的類需要註冊在不同的 bean 中，我們可以利用 import 將所有人的 beans.xml 合併為一個總的! 張三 李四 王五 applicationContext.xml 使用的時候，直接使用總的配置就可以了 有重複的別名，會覆蓋 目錄結構 beans.xml 配置 testBean.xml 配置 applicationContext.xml，import 其他 bean MyTest.java 修改 import com.kuang.pojo.User; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { // 將 beans 改為 applicationContext ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"userNew\"); user.show(); // 秦疆2 user2.show(); // 秦疆2 System.out.println(user == user2); } } 結論: 每個人可以做各自的 bean 設定，在團隊合作中常用 【狂神說Java】7、Spring 配置說明 建構子（英語： Constructor，有時簡稱 ctor），別稱：構造方法、建構函式、建構子 "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/06、DI依賴注入環境/06、DI依賴注入環境.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/06、DI依賴注入環境/06、DI依賴注入環境.html","title":"06、DI依賴注入環境","keywords":"","body":"目錄 6、DI (Dependency Injection)依賴注入環境 6-1、構造器注入 6-2、依賴注入: Set 方式注入 6-3、拓展方式注入 6、DI (Dependency Injection)依賴注入環境 6-1、構造器注入 在 【4、IOC創建對象方式】與【5、Spring配置說明】已有說明配置方法 構造器注入保證一些必要的屬性在 Bean 實例化時就得到設置，並確保了 Bean 實例化後就可以使用 6-2、依賴注入: Set 方式注入 依賴注入: Set 注入! 依賴: bean 對象的創見依賴於容器 注入: bean 對象中的所有屬性，由容器來注入 目錄結構 複雜類型 package com.kuang.pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } 真實測試對象 package com.kuang.pojo; import java.util.*; public class Student { private String name; private Address address; private String[] books; private List hobbys; private Map card; private Set games; private String wife; private Properties info; public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } public String[] getBooks() { return books; } public void setBooks(String[] books) { this.books = books; } public List getHobbys() { return hobbys; } public void setHobbys(List hobbys) { this.hobbys = hobbys; } public Map getCard() { return card; } public void setCard(Map card) { this.card = card; } public Set getGames() { return games; } public void setGames(Set games) { this.games = games; } public String getWife() { return wife; } public void setWife(String wife) { this.wife = wife; } public Properties getInfo() { return info; } public void setInfo(Properties info) { this.info = info; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", address=\" + address + \", books=\" + Arrays.toString(books) + \", hobbys=\" + hobbys + \", card=\" + card + \", games=\" + games + \", wife='\" + wife + '\\'' + \", info=\" + info + '}'; } } 新增 beans.xml 測試類 MyTest.java import com.kuang.pojo.Student; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.toString()); } } 完善注入信息 beans.xml 紅樓夢 西遊記 水滸傳 三國演義 聽歌 敲代碼 看電影 LOL COC BOB 20190525 男 小明 執行結果 Student{name='1', address=Address{address='null'}, books=[紅樓夢, 西遊記, 水滸傳, 三國演義], hobbys=[聽歌, 敲代碼, 看電影], card={身分證=111111111, 銀行卡=111111111}, games=[LOL, COC, BOB], wife='null', info={學號=20190525, 性別=男, 姓名=小明}} 6-3、拓展方式注入 我們可以使用 p 命名空間和 c 命名空間進行注入 p 命名空間，官方教學: XML Shortcut with the p-namespace c 命名空間，官方教學: XML Shortcut with the c-namespace 注意: p 命名空間和 c 命名空間不能直接使用，要導入約束! (即在 beans 添加) xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" 目錄結構 User.java 新增有參建構子 (因為C注入是使用建構子(構造器)注入的，所以需要有參的建構子(構造器)) package com.kuang.pojo; public class User { private String name; private int age; public User() { } // 添加建構子(構造器) public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 新增 userBeans.xml 修改 MyTest.java import com.kuang.pojo.Student; import com.kuang.pojo.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.toString()); } @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"userBeans.xml\"); // 後面可以定義取出來的類型，這樣就不須再強轉 User user = context.getBean(\"user\", User.class); System.out.println(user); // 使用建構子(構造器)注入 User user2 = context.getBean(\"user2\", User.class); System.out.println(user2); } } 執行結果 【狂神說Java】8、DI依賴注入環境 【狂神說Java】9、依賴注入之 set 注入 【狂神說Java】10、c 命名和 p 命名空間注入 IDEA中自动生成get/set的方式 【Spring】浅谈spring为什么推荐使用构造器注入 "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/07、Bean的作用域/07、Bean的作用域.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/07、Bean的作用域/07、Bean的作用域.html","title":"07、Bean的作用域","keywords":"","body":"目錄 7、Bean的作用域 7-1、單例模式 7-2、原型模式 7-3、其餘的 request、session、application 7、Bean的作用域 Bean scopes 7-1、單例模式 Spring 默認單例模式機制 MyTest.java import com.kuang.pojo.Student; import com.kuang.pojo.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.toString()); } @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"userBeans.xml\"); // 單例模式，每次去 get 的時候都是同一個對象 User user = context.getBean(\"user2\", User.class); User user2 = context.getBean(\"user2\", User.class); System.out.println(user.hashCode()); System.out.println(user2.hashCode()); System.out.println(user == user2); } } 執行結果 2074185499 2074185499 true 7-2、原型模式 原型模式: 每次從容器中 get 的時候，都會產生一個新的對象! MyTest.java import com.kuang.pojo.Student; import com.kuang.pojo.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.toString()); } @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"userBeans.xml\"); // 原型模式，每次去 get 的時候會產生一個新的對象 User user = context.getBean(\"user2\", User.class); User user2 = context.getBean(\"user2\", User.class); System.out.println(user.hashCode()); System.out.println(user2.hashCode()); System.out.println(user == user2); } } 執行結果 797925218 275310919 false 7-3、其餘的 request、session、application 這些只能在 web 開發中使用到! (配置 監聽器... 等等) 【狂神說Java】11、Bean 的作用域 單例模式 Singleton 【D6 - 三國鼎立時代】三大前端時代 -- 為何我選擇了Vue? [翻譯] ANGULAR VS REACT VS VUE TypeScript 10分鐘快速入門 [Angular 深入淺出三十天] Day 02 - 為什麼是 Angular？ "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/08、Bean的自動裝配/08、Bean的自動裝配.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/08、Bean的自動裝配/08、Bean的自動裝配.html","title":"08、Bean的自動裝配","keywords":"","body":"目錄 8、Bean的自動裝配 8-4、使用註解實現自動裝配 8-4-1、@Autowired 8-4-2、@Autowired(required = false) 8-5-3、@Autowired 配合 @Qualifier 8-5-4、@Nullable 8-5-5、@Resource 8-5-6、註解實現自動裝配總結 8、Bean的自動裝配 自動裝配是 Spring 滿足 bean 依賴的一種方式! Spring 會在上下文中自動尋找，並自動給 bean 裝配屬性! 在 Spring 中有三種裝配的方式 (範例下載) 在 xml 中顯示的配置 在 java 中顯示配置 隱式的自動裝配 bean 【重要!】 目錄 Cat.java package com.kuang.pojo; public class Cat { public void shout(){ System.out.println(\"miao\"); } } Dog.java package com.kuang.pojo; public class Dog { public void shout(){ System.out.println(\"wang\"); } } people.java package com.kuang.pojo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.lang.Nullable; import javax.annotation.Resource; public class People { private Cat cat; private Dog dog; private String name; public People() {} public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getName() { return name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } public void setName(String name) { this.name = name; } } beans.xml，ByName 自動裝配 beans2.xml，ByType 自動裝配 MyTest.java import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import com.kuang.pojo.People; public class MyTest { @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); People people = context.getBean(\"people\", People.class); System.out.println(people.toString()); } @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans2.xml\"); People people = context.getBean(\"people\", People.class); System.out.println(people.toString()); } } byName 的時候，需要保證所有 bean 的 id 唯一，並且這個 bean 需要和自動注入的屬性的 set 方法的值一致 ! byType 的時候，需要保證所有 bean 的 class 唯一，並且這個 bean 需要和自動注入的屬性的類型一致 ! 8-4、使用註解實現自動裝配 官方說明: Annotation-based Container Configuration jdk1.5 支持的註解，Spring2.5就支持註解了 ! The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. 要使用註解須知: 導入約束: context 配置註解的支持: context:annotation-config 【重要】 @Autowired 直接在屬性上使用即可 ! 也可以在 set 方式上使用 ! 使用 Autowired 我們可以不用編寫 Set 方法了，前提是你這個自動裝配的屬性在 IOC (Spring) 容器中存在，且符合名子 byName! public class People { @Autowired private Cat cat; @Autowired private Dog dog; } @Nullable 字段標記了這個註解，說明這個字段可以為 null public class People { private Cat cat; private Dog dog; private String name; // 表示可以空值 public People(@Nullable String name) { this.name = name; } } 如果使用 @Autowired 自動裝配的環境比較複雜，自動裝配無法通過一個註解 【@Autowired】 完成的時候，我們可以使用 @Qualifier(value=\"xxx\") 去配合 @Autowired 的使用，指定一個唯一的 bean 對象注入 ! public class People { // 如果顯示定義了 Autowired 的 required 屬性為 false，說明這個對象可以為 null，否則不允許為空 @Autowired(required = false) private Cat cat; @Autowired @Qualifier(value=\"dog2\") private Dog dog; } @Resource 和 @Autowired 的區別: 都是用來自動裝配的，都可以放在屬性 @Autowired 通過 byType 的方式實現，而且必須要求這個對象存在!【常用】 @Resource 默認通過 byName 的方式實現，如果找不到名字則通過 byType 實現! 如果兩個都找不到的情況下，就報錯!【常用】 執行順序: @Autowired 通過 byType，@Resource 默認通過 byName public class People { @Resource(name = \"cat1\") private Cat cat; @Resource private Dog dog; } 8-4-1、@Autowired 修改 beans.xml 修改 People.java (@Autowired 也可以在 set 方式上使用，但配置上 Autowired 後就可以不用寫 set 了) package com.kuang.pojo; import org.springframework.beans.factory.annotation.Autowired; public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getName() { return name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } 8-4-2、@Autowired(required = false) People.java 修改 package com.kuang.pojo; import org.springframework.beans.factory.annotation.Autowired; public class People { // 如果顯示定義了 Autowired 的 required 屬性為 false，說明這個對象可以為 null，否則不允許為空 @Autowired(required = false) private Cat cat; @Autowired private Dog dog; private String name; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getName() { return name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } beans2.xml 設定 MyTest.java 修改 import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import com.kuang.pojo.People; public class MyTest { @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans2.xml\"); People people = context.getBean(\"people\", People.class); people.getDog().shout(); people.getCat().shout(); } } 測試結果 People{cat=null, dog=com.kuang.pojo.Dog@64d2d351, name='null'} 8-5-3、@Autowired 配合 @Qualifier 修改 beans.xml People.java 修改 package com.kuang.pojo; import org.springframework.beans.factory.annotation.Autowired; public class People { @Autowired private Cat cat; @Autowired @Qualifier(value=\"dog2\") private Dog dog; private String name; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getName() { return name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } 8-5-4、@Nullable People.java，@Nullable 空值設定 package com.kuang.pojo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.lang.Nullable; public class People { private Cat cat; private Dog dog; private String name; // 表示可以空值 public People(@Nullable String name) { this.name = name; } public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getName() { return name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } 可以空值所以不一定要設定 cat 與 dog 的 bean MyTest.java @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans2.xml\"); People people = context.getBean(\"people\", People.class); System.out.println(people.toString()); } 執行結果 People{cat=null, dog=null, name='null'} Process finished with exit code 0 8-5-5、@Resource 修改 People.java public class People { @Resource private Cat cat; } 修改 bean.xml 8-5-6、註解實現自動裝配總結 project 之 pom.xml 的 常用依賴 org.springframework spring-webmvc 5.3.6 junit junit 4.12 註解說明 @Autowired: 自動裝配通過類型，名字 如果 Autowired 不能唯一自動配上屬性，則需要通過 @Qualifier(value=\"xxx\") 去配合 @Autowired 的使用，指定一個唯一的 bean 對象注入 ! @Nullable: 字段標記了這個註解，說明這個字段可以為 null @Resource: 自動裝配通過名字、類型 @Component: 組件，放在類上，說明這個類倍 Spring 管理了，就是 bean ! 【狂神說Java】12、自動裝配 Bean 【狂神說Java】13、註解實現自動裝配 "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/09、Spring使用註解開發/09、Spring使用註解開發.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/09、Spring使用註解開發/09、Spring使用註解開發.html","title":"09、Spring使用註解開發","keywords":"","body":"目錄 9、Spring 使用註解開發 9-1、xml 配合\"註解\"開發 9-2、xml 配合\"註解\"實例 9-3、使用 Java 的方式配置 Spring 9-4、使用 Java 的方式配置 Spring 實例 9、Spring 使用註解開發 9-1、xml 配合\"註解\"開發 在 Spring4 之後，要使用註解開發，必須要保證 aop 的包導入了 使用註解需要導入 context (application.xml) 約束，增加註解的支持! Bean 注入 : 將某個類註冊到 Spring 中，裝配 Bean ! POJO : @Component DAO : @Repository Service : @Service Controller : @Controller // 註冊方法 @Component public class User {} Scope 作用域 : prototype : 每次獲得 bean 都會生成一個新對象 singleton : 不會生成新對象 @Component @Scope(\"prototype\") public class User {} 小結 : xml 與 註解 : xml 更加萬能，適用於任何場合 ! 維護簡單方便 註解不是自己的類用不了，維護相對複雜 ! xml 與 註解 最佳實踐 : xml 用來管理 bean 註解只負責完成屬性的注入 我們在使用的過程中，只需要注意一個問題: 必須讓註解生效，就需要開啟註解的支持 9-2、xml 配合\"註解\"實例 目錄 創建 application.xml (導入 context 約束) 創建 User.java package com.kuang.pojo; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; // bean 注入: 將某個類註冊到 Spring 中，裝配 Bean // @Component 組件，等價於在 application.xml 中設定 (功能與 @Repository、@Service、@Controller 相同) // @Component // scope 作用域 : // @Scope(\"prototype\") 表示每宣告一個 bean 就會創造一個新對象 // 等價於 @Scope(\"prototype\") public class User { public String firstName = \"王\"; // 屬性注入: // @Value(\"大明\") 等價於在 application.xml 中設定 // // // @Value(\"大明\") public String lastName; public String nickName; // 屬性注入: // 直接在 set 上做的設定 (常用方法) @Value(\"隔壁老王\") public void setNickName(String nickName) { this.nickName = nickName; } } 創建 UserService.java package com.kuang.service; import org.springframework.stereotype.Service; // bean 注入: 將某個類註冊到 Spring 中，裝配 Bean // @Service 組件 (功能與 @Component、@Repository、@Controller 相同) @Service public class UserService { } 創建 UserController.java package com.kuang.controller; import org.springframework.stereotype.Controller; // bean 注入: 將某個類註冊到 Spring 中，裝配 Bean // @Controller 組件 (功能與 @Component、@Repository、@Service 相同) @Controller public class UserController { } 創建 UserDao.java package com.kuang.dao; import org.springframework.stereotype.Repository; // bean 注入: 將某個類註冊到 Spring 中，裝配 Bean // @Repository 組件，用於 dao 上 (功能與 @Component、@Service、@Controller 相同) @Repository public class UserDao { } 測試類 import com.kuang.pojo.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = context.getBean(\"user\", User.class); System.out.println(user.firstName + user.lastName); // 王大明 System.out.println(user.nickName); // 隔壁老王 } } 9-3、使用 Java 的方式配置 Spring 我們現在要完全不使用 Spring 的 xml 配置了，全權交給 Java 來做 ! JavaConfig 是 Spring 的一個子項目，在 Spring 4 之後，他成為了一個核心功能 ! 這種純Java 的配置方式，在 SpringBoot 中隨處可見 ! 9-4、使用 Java 的方式配置 Spring 實例 目錄 創建 User.java package com.kuang.pojo; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; // 這裡這個註解的意思，就是說明這個類被 Spring 接管了，註冊到了容器中 @Component public class User { private String name; public String getName() { return name; } // 屬性注入值 @Value(\"王大明\") public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } 創建 KuangConfig.java，作用是替代 applicatinConfig package com.kuang.config; import com.kuang.pojo.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; // @Configuration 這個也會被 Spring 容器託管，註冊到容器中，因為他本來就是一個 @Component // @Configuration 代表這是一個配置類，等同 applicationContext.xml @Configuration // @ComponentScan 等同 @ComponentScan(\"com.kuang.pojo\") // @Import，將兩個配置類合一，等同 @Import(KuangConfig2.class) public class KuangConfig { // 註冊一個 bean，就相當於我們之前寫的一個 bean 標籤，等同 // 這個方法的名子，就相當於 bean 標籤中的 id 屬性 // 這個方法的返回值，就相當於 bean 標籤中的 class 屬性 @Bean public User getUser(){ // 就是返回要注入到 bean 的對象 ! return new User(); } } 創建 KuangConfig2.java，未來要寫不同的 config.xml 不同合作不同設定時用 (主要是看何檔 @Import) package com.kuang.config; import org.springframework.context.annotation.Configuration; @Configuration public class KuangConfig2 {} 測試類 import com.kuang.config.KuangConfig; import com.kuang.pojo.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class MyTest { @Test public void test(){ // 如果完全使用了配置類方式去做，我們就只能禿過 AnnotationConfig 上下文來獲取容器，通過配置類的 class 對象加載 ! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.class); User getUser = context.getBean(\"getUser\", User.class); System.out.println(getUser.getName()); // 王大明 } } 【狂神說Java】14、Spring 註解開發 【狂神說Java】15、使用 JavaConfig 進行配置 【狂神說Java】16、上周內容回顧 SSM （SSM 框架集） Java-based Container Configuration "},"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/10、代理模式/10、代理模式.html":{"url":"【狂神说Java】Spring5最新完整教程IDEA版通俗易懂/10、代理模式/10、代理模式.html","title":"10、代理模式","keywords":"","body":"目錄 10、代理模式 10-1、靜態代理 10-2、加深靜態代理理解 10、代理模式 為什麼要學代理模式 ? 因為這是 SpringAOP 的底層 ! (面試常考 SpringAOP 與 SpringMVC) 代理模式的分類 靜態代理 動態代理 10-1、靜態代理 角色分析 : 抽象角色 : 一般會使用街口或者抽象類來解決 真實角色 : 被代理的角色 代理角色 : 代理真實角色，代理真實角色後，我們一般會做一些附屬操作 客戶 : 訪問代理對象的人 ! 靜態代理實現步驟 : 創建接口 創建真實角色 創建代理角色 客戶端訪問代理角色 目錄 創建 Rent.java 介面 (創建接口) package com.kuang.demo01; // 租房 public interface Rent { public void rent(); } 創建 Host.java 表示房東 (創建真實角色) package com.kuang.demo01; // 房東 public class Host implements Rent{ @Override public void rent() { System.out.println(\"房東要出租房子!\"); } } 創建 Proxy.java 代表房仲 (創建代理角色) package com.kuang.demo01; // 仲介 public class Proxy implements Rent{ private Host host; public Proxy(){ } public Proxy(Host host) { this.host = host; } @Override public void rent(){ seeHouse(); host.rent(); hetong(); fare(); } // 看房 public void seeHouse(){ System.out.println(\"仲介帶你看房\"); } // 收仲介費 public void fare(){ System.out.println(\"收仲介費\"); } // 簽合同 public void hetong(){ System.out.println(\"簽租賃合同\"); } } 創建 Client.java (客戶端訪問代理角色) package com.kuang.demo01; public class Client { public static void main(String[] args) { // 房東要租房子 Host host = new Host(); // 代理，中介幫房東租房子，但是呢? 代理角一般會有一些附屬操作! Proxy proxy = new Proxy(host); // 你不用面對房東，直接找仲介租房即可! proxy.rent(); } } 代理模式 : 好處 : 可以使真實角色的操作更加純粹!不用去關注一些公共的業務 公共業務也就交給代理角色!實現了業務的分工! 公共業務發生拓展的時候，方便集中管理! 缺點 : 一個真實角色就會產生一個代理角色; 代碼量會翻倍~ 開發效率會變低~ 10-2、加深靜態代理理解 聊聊 AOP AOP 加深理解與實現 : 在原有模式下是由 dao > service > controller > 前端 但開既有功能開發完成後，需要額外開發那就要用到 AOP 的實現機制 \"代理\"，進行橫向開發 目錄 創建接口 package com.kuang.demo02; // 1. 創建接口 (抽象業務) public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真實對象 package com.kuang.demo02; // 2. 真實對象 public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\"增加了一個用戶\"); } @Override public void delete() { System.out.println(\"刪除了一個用戶\"); } @Override public void update() { System.out.println(\"修改了一個用戶\"); } @Override public void query() { System.out.println(\"查詢了一個用戶\"); } } 代理角色 package com.kuang.demo02; // 3. 代理角色 public class UserServiceProxy implements UserService{ private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } @Override public void add() { log(\"add\"); userService.add(); } @Override public void delete() { log(\"delete\"); userService.add(); } @Override public void update() { log(\"update\"); userService.add(); } @Override public void query() { log(\"query\"); userService.add(); } // 日誌方法 public void log(String msg) { System.out.println(\"[Debug] 使用了\"+msg+\"方法\"); } } 客戶端訪問代理角色 package com.kuang.demo02; // 4. 客戶端訪問代理角色 public class Client { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(userService); proxy.add(); } } 【狂神說Java】17、靜態代理模式 【狂神說Java】18、靜態代理再理解 面向對象七大原則(Object-Oriented Programming System) "}}